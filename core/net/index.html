<!DOCTYPE html><html><head><meta charset='UTF-8'/>
<title>Package [io, vertx, ceylon, core, net]</title><link href='../.resources/favicon.ico' rel='shortcut icon'/>
<link href='../.resources/shCore.css' rel='stylesheet' type='text/css'/>
<link href='../.resources/shThemeDefault.css' rel='stylesheet' type='text/css'/>
<link href='../.resources/bootstrap.min.css' rel='stylesheet' type='text/css'/>
<link href='../.resources/ceylondoc.css' rel='stylesheet' type='text/css'/>
<link href='http://fonts.googleapis.com/css?family=Source+Sans+Pro|Inconsolata' rel='stylesheet' type='text/css'/>
</head><body><div class='navbar navbar-inverse navbar-static-top'><div class='navbar-inner'><a class='module-header' href='../index.html'><i class='module-logo'></i><span class='module-label'>module</span><span class='module-name'>io.vertx.ceylon.core</span><span class='module-version'>0.4.0</span></a><ul class='nav pull-right'><li class='divider-vertical' /><li><a class='expand-all' href='#' title='Expand All [Shortcut: + plus]'><i class='icon-expand-all'></i></a></li><li><a class='collapse-all' href='#' title='Collapse All [Shortcut: - minus]'><i class='icon-collapse-all'></i></a></li><li id='infoDropdown' class='dropdown'><a href='#' title='Show keyboard shortcuts [Shortcut: ?]' role='button' class='dropdown-toggle' data-toggle='dropdown'><i class='icon-info'></i></a><ul id='info-dropdown-panel' class='dropdown-menu'><h4>Keyboard Shortcuts</h4><li class='divider'></li><div class='row-fluid'><div id='info-common-shortcuts' class='span6'><div id='f'><span class='key badge'>f</span><span class='info muted'>Open filter by tags</span></div><div id='s'><span class='key badge'>s</span><span class='info muted'>Open search page</span></div><div id='?'><span class='key badge'>?</span><span class='info muted'>Open this information panel</span></div></div><div id='info-expand-collapse-shortcuts' class='span6'><div id='+'><span class='key badge'>+</span><span class='info muted'>Expand all</span></div><div id='-'><span class='key badge'>-</span><span class='info muted'>Collapse all</span></div></div></div><li class='divider'></li><div class='row-fluid'><div id='info-doc-shortcuts' class='span6'><h5>Documentation:</h5><div id='o'><span class='key badge'>o</span><span class='info muted'>Jump to module documentation</span></div><div id='p'><span class='key badge'>p</span><span class='info muted'>Jump to package documentation</span></div><div id='l'><span class='key badge'>l</span><span class='info muted'>Jump to aliases</span></div><div id='n'><span class='key badge'>n</span><span class='info muted'>Jump to annotations</span></div><div id='z'><span class='key badge'>z</span><span class='info muted'>Jump to initializer</span></div><div id='v'><span class='key badge'>v</span><span class='info muted'>Jump to values</span></div><div id='f'><span class='key badge'>f</span><span class='info muted'>Jump to functions</span></div><div id='i'><span class='key badge'>i</span><span class='info muted'>Jump to interfaces</span></div><div id='c'><span class='key badge'>c</span><span class='info muted'>Jump to classes</span></div><div id='e'><span class='key badge'>e</span><span class='info muted'>Jump to exceptions</span></div></div><div id='info-search-shortcuts' class='span6'><h5>Search page:</h5><div id='enter'><span class='key badge'>enter</span><span class='info muted'>Jump to selected declaration</span></div><div id='esc'><span class='key badge'>esc</span><span class='info muted'>Clear search query/Go to overview</span></div><div id='up'><span class='key badge'>up</span><span class='info muted'>Move selection up</span></div><div id='down'><span class='key badge'>down</span><span class='info muted'>Move selection down</span></div></div></div></ul></li></ul><ul class='nav pull-right'><li class='divider-vertical' /><li><a href='../search.html' title='Search this module [Shortcut: S]'><i class='icon-search'></i>Search</a></li></ul><ul class='nav pull-right'><li class='divider-vertical' /><li id='filterDropdown' class='dropdown'><a href='#' title='Filter declarations by tags [Shortcut: F]' role='button' class='dropdown-toggle' data-toggle='dropdown'><i class='icon-filter'></i>Filter <span id='filterDropdownLinkInfo'></span> <b class='caret'></b></a><ul id='filterDropdownPanel' class='dropdown-menu'><h4 id='filterDropdownPanelInfo'>Filter declarations by tags</h4><li class='divider'></li><div id='filterDropdownPanelTags'></div><li class='divider'></li><div id='filterActions'><a id='filterActionAll'>All</a><a id='filterActionNone'>None</a><a id='filterActionMore'>Show more</a></div></ul></li></ul></div></div><div class='sub-navbar'><div class='sub-navbar-inner'><span class='sub-navbar-label'>package</span><i class='icon-package'></i><span class='sub-navbar-name'><a class='link' href='../index.html#section-package' title='Go to package io.vertx.ceylon.core'>io.vertx.ceylon.core</a>.<a class='link-custom-text' href='../net/index.html' title='Go to package io.vertx.ceylon.core.net'>net</a></span></div><div class='sub-navbar-menu'><a href='../index.html'><span title='Jump to module documentation [Shortcut: O]'><span class='accesskey'>O</span>verview</span></a><a href='#section-classes'><span title='Jump to classes [Shortcut: C]'><span class='accesskey'>C</span>lasses</span></a></div></div><div class='container-fluid'><div class='package-description'><div class='doc'><h1>Writing TCP Servers and Clients</h1>
<p>Creating TCP servers and clients is very easy with Vert.x.</p>
<h2>Net Server</h2>
<h3>Creating a Net Server</h3>
<p>To create a TCP server you call the <a class='link' href='../Vertx.type.html#createNetServer' title='Go to io.vertx.ceylon.core::Vertx.createNetServer'>io.vertx.ceylon.core::Vertx.createNetServer</a> method on your vertx instance.</p>
<pre>value server = vertx.createNetServer();
</pre>
<h3>Start the Server Listening</h3>
<p>To tell that server to listen for connections we do:</p>
<pre>value server = vertx.createNetServer();

server.listen(1234, "myhost");
</pre>
<p>The first parameter to <a class='link' href='../net/NetServer.type.html#listen' title='Go to io.vertx.ceylon.core.net::NetServer.listen'>NetServer.listen</a> is the port. A wildcard port of <code>0</code> can be specified which means a random
available port will be chosen to actually listen at. Once the server has completed listening you can then call
the <a class='link' href='../net/NetServer.type.html#port' title='Go to io.vertx.ceylon.core.net::NetServer.port'>NetServer.port</a> attribute of the server to find out the real port it is using.</p>
<p>The second parameter is the hostname or ip address. If it is omitted it will default to <code>0.0.0.0</code> which means it
will listen at all available interfaces.</p>
<p>The actual bind is asynchronous so the server might not actually be listening until some time after the call to
listen has returned. If you want to be notified when the server is actually listening you can use the returned
promise. For example:</p>
<pre>value result = server.listen(1234);
value.onComplete {
  void onFulfilled(NetServer server) {
    print(""Listen succeeded");
  },
  void onRejected(Throwable reason) {
    print(""Listen failed");
  }
};
</pre>
<h3>Getting Notified of Incoming Connections</h3>
<p>To be notified when a connection occurs we need to call the <a class='link' href='../net/NetServer.type.html#connectHandler' title='Go to io.vertx.ceylon.core.net::NetServer.connectHandler'>NetServer.connectHandler</a> method of the server, passing
in a handler. The handler will then be called when a connection is made:</p>
<pre>value server = vertx.createNetServer();

server.connectHandler {
  void onConnect(NetSocket sock) {
    print("A client has connected!");
  }
};

server.listen(1234, "localhost");
</pre>
<p>That's a bit more interesting. Now it displays 'A client has connected!' every time a client connects.</p>
<p>The return value of the <a class='link' href='../net/NetServer.type.html#connectHandler' title='Go to io.vertx.ceylon.core.net::NetServer.connectHandler'>NetServer.connectHandler</a> method is the server itself, so multiple invocations can be
chained together. That means we can rewrite the above as:</p>
<pre>value server = vertx.createNetServer();

server.connectHandler {
  void onConnect(NetSocket sock) {
    print("A client has connected!");
  }
}.listen(1234, "localhost");
</pre>
<p>or</p>
<pre>vertx.createNetServer().connectHandler {
  void onConnect(NetSocket sock) {
    print("A client has connected!");
  }
}.listen(1234, "localhost");
</pre>
<p>This is a common pattern throughout the Vert.x API.</p>
<h3>Closing a Net Server</h3>
<p>To close a net server just call the <a class='link' href='../net/NetServer.type.html#close' title='Go to io.vertx.ceylon.core.net::NetServer.close'>NetServer.close</a> function.</p>
<pre>server.close();
</pre>
<p>he close is actually asynchronous and might not complete until some time after the <a class='link' href='../net/NetServer.type.html#close' title='Go to io.vertx.ceylon.core.net::NetServer.close'>NetServer.close</a> method has returned.
If you want to be notified when the actual close has completed then you can use the returned promise.</p>
<p>This promise will then be fulfilled when the close has fully completed.</p>
<pre>server.close().onComplete {
  void onFulfilled(Anything anything) {
    print("Close succeeded");
  },
  void onRejected(Throwable reason) {
    print("Close failed");
  }
};
</pre>
<p>If you want your net server to last the entire lifetime of your verticle, you don't need to call <a class='link' href='../net/NetServer.type.html#close' title='Go to io.vertx.ceylon.core.net::NetServer.close'>NetServer.close</a>
explicitly, the Vert.x container will automatically close any servers that you created when the verticle is undeployed.</p>
<h3>NetServer Properties</h3>
<p>NetServer has a set of properties you can set which affect its behaviour. Firstly there are bunch of properties used
to tweak the TCP parameters, in most cases you won't need to set these:</p>
<ul>
<li><a class='link' href='../ServerBase.type.html#tcpNoDelay' title='Go to io.vertx.ceylon.core::ServerBase.tcpNoDelay'>io.vertx.ceylon.core::ServerBase.tcpNoDelay</a> If true then <a href="http://en.wikipedia.org/wiki/Nagle&apos;s_algorithm">Nagle's Algorithm</a> is disabled. If false then it is enabled.</li>
<li><a class='link' href='../NetworkBase.type.html#sendBufferSize' title='Go to io.vertx.ceylon.core::NetworkBase.sendBufferSize'>io.vertx.ceylon.core::NetworkBase.sendBufferSize</a> Sets the TCP send buffer size in bytes.<br  /></li>
<li><a class='link' href='../NetworkBase.type.html#receiveBufferSize' title='Go to io.vertx.ceylon.core::NetworkBase.receiveBufferSize'>io.vertx.ceylon.core::NetworkBase.receiveBufferSize</a> Sets the TCP receive buffer size in bytes.</li>
<li><a class='link' href='../ServerBase.type.html#tcpKeepAlive' title='Go to io.vertx.ceylon.core::ServerBase.tcpKeepAlive'>io.vertx.ceylon.core::ServerBase.tcpKeepAlive</a> if tcpKeepAlive is true then TCP keep alive is enabled, if false it is disabled.</li>
<li><a class='link' href='../NetworkBase.type.html#reuseAddress' title='Go to io.vertx.ceylon.core::NetworkBase.reuseAddress'>io.vertx.ceylon.core::NetworkBase.reuseAddress</a> if reuse is true then addresses in TIME_WAIT state can be reused after they have been closed.</li>
<li><a class='link' href='../ServerBase.type.html#soLinger' title='Go to io.vertx.ceylon.core::ServerBase.soLinger'>io.vertx.ceylon.core::ServerBase.soLinger</a></li>
<li><a class='link' href='../NetworkBase.type.html#trafficClass' title='Go to io.vertx.ceylon.core::NetworkBase.trafficClass'>io.vertx.ceylon.core::NetworkBase.trafficClass</a></li>
</ul>
<p><a class='link' href='../net/NetServer.type.html' title='Go to io.vertx.ceylon.core.net::NetServer'>NetServer</a> has a further set of properties which are used to configure SSL. We'll discuss those later on.</p>
<h3>Handling Data</h3>
<p>So far we have seen how to create a NetServer, and accept incoming connections, but not how to do anything interesting
with the connections. Let's remedy that now.</p>
<p>When a connection is made, the <a class='link' href='../net/NetServer.type.html#connectHandler' title='Go to io.vertx.ceylon.core.net::NetServer.connectHandler'>NetServer.connectHandler</a> is called passing in an instance of <a class='link' href='../net/NetSocket.type.html' title='Go to io.vertx.ceylon.core.net::NetSocket'>NetSocket</a>. This is a socket-like
interface to the actual connection, and allows you to read and write data as well as do various other things like close the socket.</p>
<h4>Reading Data from the Socket</h4>
<p>To read data from the socket you need to set the <a class='link' href='../stream/ReadStream.type.html#dataHandler' title='Go to io.vertx.ceylon.core.stream::ReadStream.dataHandler'>io.vertx.ceylon.core.stream::ReadStream.dataHandler</a> on the <a class='link' href='../net/NetSocket.type.html#readStream' title='Go to io.vertx.ceylon.core.net::NetSocket.readStream'>NetSocket.readStream</a>.
This handler will be called with an instance of <span title='org.vertx.java.core.buffer::Buffer'>org.vertx.java.core.buffer::Buffer</span> every time data is received on the
socket. You could try the following code and telnet to it to send some data:</p>
<pre>value server = vertx.createNetServer();

server.connectHandler {
  void onConnect(NetSocket sock) {
    sock.readStream.dataHandler {
      void onData(Buffer buffer) {
        print("I received ``buffer.length()`` bytes of data"));
      }
    }
  }
}.listen(1234, "localhost");;
</pre>
<h4>Writing Data to a Socket</h4>
<p>To write data to a socket, you invoke the <a class='link' href='../net/NetSocket.type.html#write' title='Go to io.vertx.ceylon.core.net::NetSocket.write'>NetSocket.write</a> function. This function can be invoked in a few ways:</p>
<p>With a single buffer:</p>
<pre>value myBuffer = Buffer(...);
sock.write(myBuffer);
</pre>
<p>A string. In this case the string will encoded using UTF-8 and the result written to the wire.</p>
<pre>sock.write("hello");
</pre>
<p>A string and an encoding. In this case the string will encoded using the specified encoding and the result written to the wire.</p>
<pre>sock.write(["hello", "UTF-16"]);
</pre>
<p>The <a class='link' href='../net/NetSocket.type.html#write' title='Go to io.vertx.ceylon.core.net::NetSocket.write'>NetSocket.write</a> function is asynchronous and always returns immediately after the write has been queued. Let's put it all together.</p>
<p>Here's an example of a simple TCP echo server which simply writes back (echoes) everything that it receives on the socket:</p>
<pre>value server = vertx.createNetServer();

server.connectHandler {
  void onConnect(NetSocket sock) {
    sock.readStream.dataHandler {
      void onData(Buffer buffer) {
        sock.write(buffer);
      }
    }
  }
}.listen(1234, "localhost");;
</pre>
<h4>Socket Remote Address</h4>
<p>You can find out the remote address of the socket (i.e. the address of the other side of the TCP IP connection) by calling
<a class='link' href='../net/NetSocket.type.html#remoteAddress' title='Go to io.vertx.ceylon.core.net::NetSocket.remoteAddress'>NetSocket.remoteAddress</a>.</p>
<h4>Socket Local Address</h4>
<p>You can find out the local address of the socket (i.e. the address of this side of the TCP IP connection) by calling
<a class='link' href='../net/NetSocket.type.html#localAddress' title='Go to io.vertx.ceylon.core.net::NetSocket.localAddress'>NetSocket.localAddress</a>.</p>
<h4>Closing a socket</h4>
<p>You can close a socket by invoking the <a class='link' href='../net/NetSocket.type.html#close' title='Go to io.vertx.ceylon.core.net::NetSocket.close'>NetSocket.close</a> method. This will close the underlying TCP connection.</p>
<h4>Closed Handler</h4>
<p>If you want to be notified when a socket is closed, you can use the <a class='link' href='../net/NetSocket.type.html#closeHandler' title='Go to io.vertx.ceylon.core.net::NetSocket.closeHandler'>NetSocket.closeHandler</a> promise:</p>
<pre>value server = vertx.createNetServer();

server.connectHandler {
  void onConnect(NetSocket sock) {
    sock.closeHandler.onComplete {
      void onFulfilled(Anything anything) {
        print("The socket is now closed");
      }
    }
  }
}.listen(1234, "localhost");;
</pre>
<p>The closed handler will be called irrespective of whether the close was initiated by the client or server.</p>
<h4>Exception handler</h4>
<p>You can set an exception handler on the socket that will be called if an exception occurs asynchronously on the connection:</p>
<pre>value server = vertx.createNetServer();

server.connectHandler {
  void onConnect(NetSocket sock) {
    sock.readStream.exceptionHandler {
      void onException(Throwable cause) {
        print("Oops, something went wrong");
        t.printStackTrace();
      }
    }
  }
}.listen(1234, "localhost");;
</pre>
<h4>Event Bus Write Handler</h4>
<p>Every NetSocket automatically registers a handler on the event bus, and when any buffers are received in this handler,
it writes them to itself. This enables you to write data to a NetSocket which is potentially in a completely different
verticle or even in a different Vert.x instance by sending the buffer to the address of that handler.</p>
<p>The address of the handler is given by the <a class='link' href='../net/NetSocket.type.html#writeHandlerID' title='Go to io.vertx.ceylon.core.net::NetSocket.writeHandlerID'>NetSocket.writeHandlerID</a> attribute.</p>
<p>For example to write some data to the NetSocket from a completely different verticle you could do:</p>
<pre>String writeHandlerID = ... // E.g. retrieve the ID from shared data

vertx.eventBus().send(writeHandlerID, buffer);
</pre>
<h4>Read and Write Streams</h4>
<p>NetSocket provide access to <a class='link' href='../net/NetSocket.type.html#readStream' title='Go to io.vertx.ceylon.core.net::NetSocket.readStream'>io.vertx.ceylon.core.net::NetSocket.readStream</a> and <a class='link' href='../net/NetSocket.type.html#writeStream' title='Go to io.vertx.ceylon.core.net::NetSocket.writeStream'>io.vertx.ceylon.core.net::NetSocket.writeStream</a>.
This allows flow control to occur on the connection and the connection data to be pumped to and from other object such
as HTTP requests and responses, WebSockets and asynchronous files.</p>
<p>This will be discussed in depth in the chapter on streams and pumps.</p>
<h3>Scaling TCP Servers</h3>
<p>A verticle instance is strictly single threaded.</p>
<p>If you create a simple TCP server and deploy a single instance of it then all the handlers for that server are
always executed on the same event loop (thread).</p>
<p>This means that if you are running on a server with a lot of cores, and you only have this one instance deployed
then you will have at most one core utilised on your server!</p>
<p>To remedy this you can simply deploy more instances of the module in the server, e.g.</p>
<pre>vertx runmod com.mycompany~my-mod~1.0 -instances 20
</pre>
<p>Or for a raw verticle</p>
<pre>vertx run foo.MyApp -instances 20
</pre>
<p>The above would run 20 instances of the module/verticle in the same Vert.x instance.</p>
<p>Once you do this you will find the echo server works functionally identically to before, but, as if by magic, all your
cores on your server can be utilised and more work can be handled.</p>
<p>At this point you might be asking yourself '<em>Hold on, how can you have more than one server listening on the same host and
port? Surely you will get port conflicts as soon as you try and deploy more than one instance?</em>'</p>
<p>Vert.x does a little magic here.</p>
<p>When you deploy another server on the same host and port as an existing server it doesn't actually try and create
a new server listening on the same host/port.</p>
<p>Instead it internally maintains just a single server, and, as incoming connections arrive it distributes
them in a round-robin fashion to any of the connect handlers set by the verticles.</p>
<p>Consequently Vert.x TCP servers can scale over available cores while each Vert.x verticle instance remains
strictly single threaded, and you don't have to do any special tricks like writing load-balancers in order to
scale your server on your multi-core machine.</p>
<h2>Net Client</h2>
<p>A NetClient is used to make TCP connections to servers.</p>
<h3>Creating a Net Client</h3>
<p>To create a TCP client you call the <a class='link' href='../Vertx.type.html#createNetClient' title='Go to io.vertx.ceylon.core::Vertx.createNetClient'>io.vertx.ceylon.core::Vertx.createNetClient</a> method on your vertx instance.</p>
<pre>value Netclient = vertx.createNetClient();
</pre>
<h3>Making a Connection</h3>
<p>To actually connect to a server you invoke the <a class='link' href='../net/NetClient.type.html#connect' title='Go to io.vertx.ceylon.core.net::NetClient.connect'>NetClient.connect</a> method:</p>
<pre>value Netclient = vertx.createNetClient();

Promise&lt;NetSocket&gt; connect = client.connect(1234, "localhost");
connect.onComplete {
  void onFulfilled(NetSocket socket) {
    print(""We have connected! Socket is ``socket``");
  },
  void onRejected(Throwable reason) {
    reason.printStackTrace();
  }
};
</pre>
<p>The connect method takes the port number as the first parameter, followed by the hostname or ip address of
the server. The third parameter is a connect handler. This handler will be called when the connection actually occurs.</p>
<p>The argument returned by <a class='link' href='../net/NetClient.type.html#connect' title='Go to io.vertx.ceylon.core.net::NetClient.connect'>NetClient.connect</a> is a <code>Promise&lt;NetSocket&gt;</code> fulfilled with the <a class='link' href='../net/NetSocket.type.html' title='Go to io.vertx.ceylon.core.net::NetSocket'>NetSocket</a>. You can read
and write data from the socket in exactly the same way as you do on the server side.</p>
<p>You can also close it, set the closed handler, set the exception handler and use it as a <code>ReadStream</code> or <code>WriteStream</code>
exactly the same as the server side <a class='link' href='../net/NetSocket.type.html' title='Go to io.vertx.ceylon.core.net::NetSocket'>NetSocket</a>.</p>
<h3>Configuring Reconnection</h3>
<p>A NetClient can be configured to automatically retry connecting or reconnecting to the server in the event that it
cannot connect or has lost its connection. This is done by setting the <a class='link' href='../net/NetClient.type.html#reconnectAttempts' title='Go to io.vertx.ceylon.core.net::NetClient.reconnectAttempts'>NetClient.reconnectAttempts</a> and
<a class='link' href='../net/NetClient.type.html#reconnectInterval' title='Go to io.vertx.ceylon.core.net::NetClient.reconnectInterval'>NetClient.reconnectInterval</a> attributes:</p>
<pre>value client = vertx.createNetClient();
client.reconnectAttempts = 1000;
client.reconnectInterval = 500;
</pre>
<p><code>reconnectAttempts</code> determines how many times the client will try to connect to the server before giving up
A value of <code>-1</code> represents an infinite number of times. The default value is <code>0</code>. I.e. no reconnection is attempted.</p>
<p><code>reconnectInterval</code> detemines how long, in milliseconds, the client will wait between reconnect attempts. The default
value is <code>1000</code>.</p>
<h3>NetClient Properties</h3>
<p>Just like <a class='link' href='../net/NetServer.type.html' title='Go to io.vertx.ceylon.core.net::NetServer'>NetServer</a>, <a class='link' href='../net/NetClient.type.html' title='Go to io.vertx.ceylon.core.net::NetClient'>NetClient</a> also has a set of TCP properties you can set which affect its behaviour.
They have the same meaning as those on <a class='link' href='../net/NetServer.type.html' title='Go to io.vertx.ceylon.core.net::NetServer'>NetServer</a>.</p>
<p><a class='link' href='../net/NetClient.type.html' title='Go to io.vertx.ceylon.core.net::NetClient'>NetClient</a> also has a further set of properties which are used to configure SSL. We'll discuss those later on.</p>
<h2>SSL Servers</h2>
<p>Net servers can also be configured to work with <a href="http://en.wikipedia.org/wiki/Transport_Layer_Security">Transport Layer Security</a> (previously known as SSL).</p>
<p>When a <a class='link' href='../net/NetServer.type.html' title='Go to io.vertx.ceylon.core.net::NetServer'>NetServer</a> is working as an SSL Server the API of the <a class='link' href='../net/NetServer.type.html' title='Go to io.vertx.ceylon.core.net::NetServer'>NetServer</a> and <a class='link' href='../net/NetSocket.type.html' title='Go to io.vertx.ceylon.core.net::NetSocket'>NetSocket</a> is identical compared to
when it working with standard sockets. Getting the server to use SSL is just a matter of configuring the <a class='link' href='../net/NetServer.type.html' title='Go to io.vertx.ceylon.core.net::NetServer'>NetServer</a>
before <a class='link' href='../net/NetServer.type.html#listen' title='Go to io.vertx.ceylon.core.net::NetServer.listen'>NetServer.listen</a> is called.</p>
<p>To enabled SSL the attribute <a class='link' href='../NetworkBase.type.html#ssl' title='Go to io.vertx.ceylon.core::NetworkBase.ssl'>io.vertx.ceylon.core::ServerBase.ssl</a> must be called on the Net Server.</p>
<p>The server must also be configured with a <em>key store</em> and an optional <em>trust store</em>.</p>
<p>These are both <em>Java keystores</em> which can be managed using the <a href="http://docs.oracle.com/javase/6/docs/technotes/tools/solaris/keytool.html">keytool</a>
utility which ships with the JDK.</p>
<p>The keytool command allows you to create keystores, and import and export certificates from them.</p>
<p>The key store should contain the server certificate. This is mandatory - the client will not be able to connect
to the server over SSL if the server does not have a certificate.</p>
<p>The key store is configured on the server using the <a class='link' href='../NetworkBase.type.html#keyStorePath' title='Go to io.vertx.ceylon.core::NetworkBase.keyStorePath'>io.vertx.ceylon.core::NetworkBase.keyStorePath</a> and
<a class='link' href='../NetworkBase.type.html#keyStorePassword' title='Go to io.vertx.ceylon.core::NetworkBase.keyStorePassword'>io.vertx.ceylon.core::NetworkBase.keyStorePassword</a> methods.</p>
<p>The trust store is optional and contains the certificates of any clients it should trust. This is only used if client
authentication is required.</p>
<p>To configure a server to use server certificates only:</p>
<pre>value server = vertx.createNetServer();
server.ssl = true;
server.keyStorePath = "/path/to/your/keystore/server-keystore.jks";
server.keyStorePassword = "password";
</pre>
<p>Making sure that <code>server-keystore.jks</code> contains the server certificate.</p>
<p>To configure a server to also require client certificates:</p>
<pre>value server = vertx.createNetServer();
server.ssl = true;
server.keyStorePath = "/path/to/your/keystore/server-keystore.jks";
server.keyStorePassword = "password";
server.trustStorePath = "/path/to/your/keystore/server-truststore.jks";
server.trustStorePassword = "password";
server.clientAuthRequired = true;
</pre>
<p>Making sure that <code>server-truststore.jks</code> contains the certificates of any clients who the server trusts.</p>
<p>If <code>clientAuthRequired</code> is set to `true and the client cannot provide a certificate, or it provides a certificate that the server does not trust then the connection attempt will not succeed.</p>
<h2>SSL Clients</h2>
<p>Net Clients can also be easily configured to use SSL. They have the exact same API when using SSL as when using standard sockets.</p>
<p>To enable SSL on a <a class='link' href='../net/NetClient.type.html' title='Go to io.vertx.ceylon.core.net::NetClient'>NetClient</a> the attribute <a class='link' href='../NetworkBase.type.html#ssl' title='Go to io.vertx.ceylon.core::NetworkBase.ssl'>io.vertx.ceylon.core::NetworkBase.ssl</a> is set to <code>true</code>.</p>
<p>If the <a class='link' href='../ClientBase.type.html#trustAll' title='Go to io.vertx.ceylon.core::ClientBase.trustAll'>io.vertx.ceylon.core::ClientBase.trustAll</a> is invoked on the client, then the client will trust all server
certificates. The connection will still be encrypted but this mode is vulnerable to 'man in the middle'
ttacks. I.e. you can't be sure who you are connecting to. Use this with caution. Default value is <code>false</code>.</p>
<p>If <a class='link' href='../ClientBase.type.html#trustAll' title='Go to io.vertx.ceylon.core::ClientBase.trustAll'>io.vertx.ceylon.core::ClientBase.trustAll</a> has not been set to <code>true</code> then a client trust store must be configured and
should contain the certificates of the servers that the client trusts.</p>
<p>The client trust store is just a standard Java key store, the same as the key stores on the server side. The client
trust store location is set by using the attribute <a class='link' href='../NetworkBase.type.html#trustStorePath' title='Go to io.vertx.ceylon.core::NetworkBase.trustStorePath'>io.vertx.ceylon.core::NetworkBase.trustStorePath</a> on the <a class='link' href='../net/NetClient.type.html' title='Go to io.vertx.ceylon.core.net::NetClient'>NetClient</a>. If a server presents a certificate
during connection which is not in the client trust store, the connection attempt will not succeed.</p>
<p>If the server requires client authentication then the client must present its own certificate to the server
when connecting. This certificate should reside in the client key store. Again it's just a regular Java key store.
The client keystore location is set by using the <a class='link' href='../NetworkBase.type.html#keyStorePath' title='Go to io.vertx.ceylon.core::NetworkBase.keyStorePath'>io.vertx.ceylon.core::NetworkBase.keyStorePath</a> attribute on the <a class='link' href='../net/NetClient.type.html' title='Go to io.vertx.ceylon.core.net::NetClient'>NetClient</a>.</p>
<p>To configure a client to trust all server certificates (dangerous):</p>
<pre>value client = vertx.createNetClient();
client.ssl = true;
client.trustAll = true;
</pre>
<p>To configure a client to only trust those certificates it has in its trust store:</p>
<pre>value client = vertx.createNetClient();
client.ssl = true;
client.trustStorePath = "/path/to/your/client/truststore/client-truststore.jks";
client.trustStorePassword = "password";
</pre>
<p>To configure a client to only trust those certificates it has in its trust store, and also to supply a client certificate:</p>
<pre>value client = vertx.createNetClient();
client.ssl = true;
client.trustStorePath = "/path/to/your/client/truststore/client-truststore.jks";
client.trustStorePassword = "password";
client.clientAuthRequired = true;
client.keyStorePath = "/path/to/keystore/holding/client/cert/client-keystore.jks";
client.keyStorePassword = "password";
</pre>
</div></div><table id='section-classes' class='table table-condensed table-bordered table-hover'><thead><tr class='table-header' title='Click for expand/collapse'><td colspan='2'><i class='icon-expand'></i>Classes</td></tr></thead><tbody><tr><td id='NetClient' nowrap><i class='icon-class'></i><a class='link-discreet' href='../net/NetClient.type.html'>NetClient</a></td><td><a class='link-one-self' title='Link to this declaration' href='../net/index.html#NetClient'><i class='icon-link'></i></a><div class='signature'><span class='modifiers'>shared</span> <a class='link' href='../net/NetClient.type.html' title='Go to io.vertx.ceylon.core.net::NetClient'>NetClient</a></div><div class='description'><div class='doc section'><p>A TCP/SSL client.
Multiple connections to different servers can be made using the same instance.</p>
<p>This client supports a configurable number of connection attempts and a configurable
delay between attempts.</p>
<p>If an instance is instantiated from an event loop then the handlers
of the instance will always be called on that same event loop.
If an instance is instantiated from some other arbitrary Java thread (i.e. when using embedded) then
an event loop will be assigned to the instance and used when any of its handlers
are called.</p>
<p>Instances of this class are thread-safe.</p>
</div></div></td></tr><tr><td id='NetServer' nowrap><i class='icon-class'></i><a class='link-discreet' href='../net/NetServer.type.html'>NetServer</a></td><td><a class='link-one-self' title='Link to this declaration' href='../net/index.html#NetServer'><i class='icon-link'></i></a><div class='signature'><span class='modifiers'>shared</span> <a class='link' href='../net/NetServer.type.html' title='Go to io.vertx.ceylon.core.net::NetServer'>NetServer</a></div><div class='description'><div class='doc section'><p>Represents a TCP or SSL server</p>
<p>If an instance is instantiated from an event loop then the handlers
of the instance will always be called on that same event loop.
If an instance is instantiated from some other arbitrary Java thread (i.e. when running embedded) then
and event loop will be assigned to the instance and used when any of its handlers
are called.</p>
<p>Instances of this class are thread-safe.</p>
</div></div></td></tr><tr><td id='NetSocket' nowrap><i class='icon-class'></i><a class='link-discreet' href='../net/NetSocket.type.html'>NetSocket</a></td><td><a class='link-one-self' title='Link to this declaration' href='../net/index.html#NetSocket'><i class='icon-link'></i></a><div class='signature'><span class='modifiers'>shared</span> <a class='link' href='../net/NetSocket.type.html' title='Go to io.vertx.ceylon.core.net::NetSocket'>NetSocket</a></div><div class='description'><div class='doc section'><p>Represents a socket-like interface to a TCP/SSL connection on either the
client or the server side.</p>
<p>Instances of this class are created on the client side by an <a class='link' href='../net/NetClient.type.html' title='Go to io.vertx.ceylon.core.net::NetClient'>NetClient</a>
when a connection to a server is made, or on the server side by a <a class='link' href='../net/NetServer.type.html' title='Go to io.vertx.ceylon.core.net::NetServer'>NetServer</a>
when a server accepts a connection.</p>
<p>It provides access to both <a class='link' href='../net/NetSocket.type.html#readStream' title='Go to io.vertx.ceylon.core.net::NetSocket.readStream'>readStream</a> and <a class='link' href='../net/NetSocket.type.html#writeStream' title='Go to io.vertx.ceylon.core.net::NetSocket.writeStream'>writeStream</a> so it can be used with
<a class='link' href='../stream/Pump.type.html' title='Go to io.vertx.ceylon.core.stream::Pump'>io.vertx.ceylon.core.stream::Pump</a> to pump data with flow control.</p>
<p>Instances of this class are not thread-safe.</p>
</div></div></td></tr></tbody></table></div><script type='text/javascript'>var resourceBaseUrl = '../.resources/'</script><script type='text/javascript' src='../.resources/jquery-1.8.2.min.js'></script><script type='text/javascript' src='../.resources/bootstrap.min.js'></script><script type='text/javascript' src='../.resources/shCore.js'></script><script type='text/javascript' src='../.resources/shAutoloader.js'></script><script type='text/javascript' src='../.resources/shBrushCeylon.js'></script><script type='text/javascript' src='../.resources/index.js'></script><script type='text/javascript' src='../.resources/ceylondoc.js'></script><script type='text/javascript'>jQuery('html').keypress(function(evt){
  evt = evt || window.event;
  var keyCode = evt.keyCode || evt.which;
  if( !evt.ctrlKey && !evt.altKey ) {
    if (keyCode == 63) {
      $('#infoDropdown > .dropdown-toggle').click();
    }
    if(keyCode == 115){
      document.location = '../search.html';
    }
    if(keyCode == 99){
      document.location = '#section-classes';
    }
    if(keyCode == 112){
      document.location = 'index.html';
    }
    if(keyCode == 111){
      document.location = '../index.html';
    }
  }
});
enableInfoKeybordShortcut('\\?');
enableInfoKeybordShortcut('s');
enableInfoKeybordShortcut('c');
enableInfoKeybordShortcut('p');
enableInfoKeybordShortcut('o');
</script></body></html>