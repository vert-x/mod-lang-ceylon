<!DOCTYPE html><html><head><meta charset='UTF-8'/>
<title>Package [io, vertx, ceylon, eventbus]</title><link href='../.resources/favicon.ico' rel='shortcut icon'/>
<link href='../.resources/shCore.css' rel='stylesheet' type='text/css'/>
<link href='../.resources/shThemeDefault.css' rel='stylesheet' type='text/css'/>
<link href='../.resources/bootstrap.min.css' rel='stylesheet' type='text/css'/>
<link href='../.resources/ceylondoc.css' rel='stylesheet' type='text/css'/>
</head><body><div class='navbar navbar-inverse navbar-static-top'><div class='navbar-inner'><a class='module-header' href='../index.html'><i class='module-logo'></i><span class='module-label'>module</span><span class='module-name'>io.vertx.ceylon</span><span class='module-version'>0.4.0</span></a><ul class='nav pull-right'><li class='divider-vertical' /><li><a class='expand-all' href='#' title='Expand All [Shortcut: + plus]'><i class='icon-expand-all'></i></a></li><li><a class='collapse-all' href='#' title='Collapse All [Shortcut: - minus]'><i class='icon-collapse-all'></i></a></li><li id='infoDropdown' class='dropdown'><a href='#' title='Show keyboard shortcuts [Shortcut: ?]' role='button' class='dropdown-toggle' data-toggle='dropdown'><i class='icon-info'></i></a><ul id='info-dropdown-panel' class='dropdown-menu'><h4>Keyboard Shortcuts</h4><li class='divider'></li><div class='row-fluid'><div id='info-common-shortcuts' class='span6'><div id='f'><span class='key badge'>f</span><span class='info muted'>Open filter by tags</span></div><div id='s'><span class='key badge'>s</span><span class='info muted'>Open search page</span></div><div id='?'><span class='key badge'>?</span><span class='info muted'>Open this information panel</span></div></div><div id='info-expand-collapse-shortcuts' class='span6'><div id='+'><span class='key badge'>+</span><span class='info muted'>Expand all</span></div><div id='-'><span class='key badge'>-</span><span class='info muted'>Collapse all</span></div></div></div><li class='divider'></li><div class='row-fluid'><div id='info-doc-shortcuts' class='span6'><h5>Documentation:</h5><div id='o'><span class='key badge'>o</span><span class='info muted'>Jump to module documentation</span></div><div id='p'><span class='key badge'>p</span><span class='info muted'>Jump to package documentation</span></div><div id='l'><span class='key badge'>l</span><span class='info muted'>Jump to aliases</span></div><div id='n'><span class='key badge'>n</span><span class='info muted'>Jump to annotations</span></div><div id='z'><span class='key badge'>z</span><span class='info muted'>Jump to initializer</span></div><div id='v'><span class='key badge'>v</span><span class='info muted'>Jump to values</span></div><div id='f'><span class='key badge'>f</span><span class='info muted'>Jump to functions</span></div><div id='i'><span class='key badge'>i</span><span class='info muted'>Jump to interfaces</span></div><div id='c'><span class='key badge'>c</span><span class='info muted'>Jump to classes</span></div><div id='e'><span class='key badge'>e</span><span class='info muted'>Jump to exceptions</span></div></div><div id='info-search-shortcuts' class='span6'><h5>Search page:</h5><div id='enter'><span class='key badge'>enter</span><span class='info muted'>Jump to selected declaration</span></div><div id='esc'><span class='key badge'>esc</span><span class='info muted'>Clear search query/Go to overview</span></div><div id='up'><span class='key badge'>up</span><span class='info muted'>Move selection up</span></div><div id='down'><span class='key badge'>down</span><span class='info muted'>Move selection down</span></div></div></div></ul></li></ul><ul class='nav pull-right'><li class='divider-vertical' /><li><a href='../search.html' title='Search this module [Shortcut: S]'><i class='icon-search'></i>Search</a></li></ul><ul class='nav pull-right'><li class='divider-vertical' /><li id='filterDropdown' class='dropdown'><a href='#' title='Filter declarations by tags [Shortcut: F]' role='button' class='dropdown-toggle' data-toggle='dropdown'><i class='icon-filter'></i>Filter <span id='filterDropdownLinkInfo'></span> <b class='caret'></b></a><ul id='filterDropdownPanel' class='dropdown-menu'><h4 id='filterDropdownPanelInfo'>Filter declarations by tags</h4><li class='divider'></li><div id='filterDropdownPanelTags'></div><li class='divider'></li><div id='filterActions'><a id='filterActionAll'>All</a><a id='filterActionNone'>None</a><a id='filterActionMore'>Show more</a></div></ul></li></ul></div></div><div class='sub-navbar'><div class='sub-navbar-inner'><span class='sub-navbar-label'>package</span><i class='icon-package'></i><span class='sub-navbar-name'><a class='link' href='../index.html#section-package' title='Go to package io.vertx.ceylon'>io.vertx.ceylon</a>.<a class='link-custom-text' href='../eventbus/index.html' title='Go to package io.vertx.ceylon.eventbus'>eventbus</a></span></div><div class='sub-navbar-menu'><a href='../index.html'><span title='Jump to module documentation [Shortcut: O]'><span class='accesskey'>O</span>verview</span></a><a href='#section-aliases'><span title='Jump to aliases [Shortcut: l]'>A<span class='accesskey'>l</span>iases</span></a><a href='#section-classes'><span title='Jump to classes [Shortcut: C]'><span class='accesskey'>C</span>lasses</span></a></div></div><div class='container-fluid'><div class='package-description'><div class='doc'><h1>The Event Bus</h1>
<p>The event bus is the nervous system of Vert.x.</p>
<p>It allows verticles to communicate with each other irrespective of what language they are written in, and whether
they're in the same Vert.x instance, or in a different Vert.x instance.</p>
<p>It even allows client side JavaScript running in a browser to communicate on the same event bus. (More on that later).</p>
<p>The event bus forms a distributed peer-to-peer messaging system spanning multiple server nodes and multiple browsers.</p>
<p>The event bus API is incredibly simple. It basically involves registering handlers, unregistering handlers and
sending and publishing messages.</p>
<p>First some theory:<br  /></p>
<h1>The Theory</h1>
<h2>Addressing</h2>
<p>Messages are sent on the event bus to an address.</p>
<p>Vert.x doesn't bother with any fancy addressing schemes. In Vert.x an address is simply a string, any string is
valid. However it is wise to use some kind of scheme, e.g. using periods to demarcate a namespace.</p>
<p>Some examples of valid addresses are <code>europe.news.feed1</code>, <code>acme.games.pacman</code>, <code>sausages</code>, and <code>X</code>.</p>
<h2>Handlers</h2>
<p>A handler is a thing that receives messages from the bus. You register a handler at an address.</p>
<p>Many different handlers from the same or different verticles can be registered at the same address.
A single handler can be registered by the verticle at many different addresses.</p>
<h2>Publish / subscribe messaging</h2>
<p>The event bus supports <em>publishing</em> messages. Messages are published to an address. Publishing means delivering
the message to all handlers that are registered at that address. This is the familiar <em>publish/subscribe</em> messaging pattern.</p>
<h2>Point to point and Request-Response messaging</h2>
<p>The event bus supports <em>point to point</em> messaging. Messages are sent to an address. Vert.x will then route it to just
one of the handlers registered at that address. If there is more than one handler registered at the address,
one will be chosen using a non-strict round-robin algorithm.</p>
<p>With point to point messaging, an optional reply handler can be specified when sending the message. When a message
is received by a recipient, and has been handled, the recipient can optionally decide to reply to the message. If they
do so that reply handler will be called.</p>
<p>When the reply is received back at the sender, it too can be replied to. This can be repeated ad-infinitum, and
allows a dialog to be set-up between two different verticles. This is a common messaging pattern called the Request-Response pattern.</p>
<h2>Transient</h2>
<p><em>All messages in the event bus are transient, and in case of failure of all or parts of the event bus, there is a
possibility messages will be lost. If your application cares about lost messages, you should code your handlers to be
idempotent, and your senders to retry after recovery.</em></p>
<p>If you want to persist your messages you can use a persistent work queue module for that.</p>
<h2>Types of messages</h2>
<p>Messages that you send on the event bus can be as simple as a string, a number or a boolean. You can also send Vert.x buffers or JSON messages.</p>
<p>It's highly recommended you use JSON messages to communicate between verticles. JSON is easy to create and parse in all the
languages that Vert.x supports.</p>
<h1>Event Bus API</h1>
<p>Let's jump into the API.</p>
<h2>Registering and Unregistering Handlers</h2>
<p>To set a message handler on the address <code>test.address</code>, you do something like the following:</p>
<pre>value eb = vertx.eventBus();
function myHandler(Message message) =&gt; print("I received a message ``message.body``");
eb.registerHandler("test.address", myHandler);
</pre>
<p>It's as simple as that. The handler will then receive any messages sent to that address.</p>
<p>The class <a class='link' href='../eventbus/Message.type.html' title='Go to io.vertx.ceylon.eventbus::Message'>Message</a> is a generic type and specific Message types include:</p>
<ul>
<li><code>Message&lt;String&gt;</code> : mapped to Ceylon <code>String</code></li>
<li><code>Message&lt;Boolean&gt;</code> : mapped to Ceylon <code>Boolean</code></li>
<li><code>Message&lt;byte[]&gt;</code> : mapped to <code>java.lang.ByteArray</code> virtual type</li>
<li><code>Message&lt;Double&gt;</code> : mapped to Ceylon <code>Float</code></li>
<li><code>Message&lt;JsonObject&gt;</code> : mapped to <code>ceylon.json.Object</code></li>
<li><code>Message&lt;JsonArray&gt;</code> : mapped to <code>ceylon.json.Array</code></li>
<li><code>Message&lt;Long&gt;</code> : mapped to Ceylon <code>Integer</code></li>
<li><code>Message&lt;Buffer&gt;</code> : not supported at the moment</li>
<li><code>Message&lt;Byte&gt;</code> : not supported at the moment</li>
<li><code>Message&lt;Character&gt;</code> : not supported at the moment</li>
<li><code>Message&lt;Float&gt;</code> : not supported at the moment</li>
<li><code>Message&lt;Integer&gt;</code> : not supported at the moment</li>
<li><code>Message&lt;Short&gt;</code> : not supported at the moment</li>
</ul>
<p>If you know you'll always be receiving messages of a particular type you can use the specific type in your handler, e.g:</p>
<pre>void myHandler(Message&lt;String&gt; message) {
   String body = message.body;
}
</pre>
<p>The return value of <a class='link' href='../eventbus/EventBus.type.html#registerHandler' title='Go to io.vertx.ceylon.eventbus::EventBus.registerHandler'>EventBus.registerHandler</a> is a <a class='link' href='../Registration.type.html' title='Go to io.vertx.ceylon::Registration'>io.vertx.ceylon::Registration</a> object that allows to unregister an handler:</p>
<pre>value registration = eb.registerHandler("test.address", myHandler);
registration.cancel();
</pre>
<p>When you register a handler on an address and you're in a cluster it can take some time for the knowledge of that
new handler to be propagated across the entire cluster. If you want to be notified you can use the <a class='link' href='../Registration.type.html#completed' title='Go to io.vertx.ceylon::Registration.completed'>io.vertx.ceylon::Registration.completed</a>
<code>Promise</code> object. This promise will then be resolved once the information has reached all nodes of the cluster.</p>
<pre>value registration = eb.registerHandler("test.address", myHandler);
registration.completed.then_(
 (Registration registration) =&gt; print("The handler has been registered across the cluster",
 (Exception failure) =&gt; print("The handler has not been registered across the cluster: ``failure.message`"
);
</pre>
<p>If you want your handler to live for the full lifetime of your verticle there is no need to unregister it explicitly - Vert.x will
automatically unregister any handlers when the verticle is stopped.</p>
<h2>Publishing messages</h2>
<p>Publishing a message is also trivially easy. Just publish it specifying the address, for example:</p>
<pre>eb.publish("test.address", "hello world");
</pre>
<p>That message will then be delivered to all handlers registered against the address <code>test.address</code>.</p>
<h2>Sending messages</h2>
<p>Sending a message will result in only one handler registered at the address receiving the message. This is the point to point messaging pattern.
The handler is chosen in a non strict round-robin fashion.</p>
<pre>eb.send("test.address", "hello world");
</pre>
<h2>Replying to messages</h2>
<p>Sometimes after you send a message you want to receive a reply from the recipient. This is known as the <em>request-response</em> pattern.</p>
<p>To do this you send a message, and specify a specify a return type that you expected: the various methods for sending messages
return a <code>Promise&lt;Message&lt;M&gt;&gt;</code> that is resolved when the reply is received, when no type is not specified it falls down to
<code>Nothing</code>. When the receiver receives the message they can reply to it by calling the reply method on the message.
When this method is invoked it causes a reply to be sent back to the sender where the reply Promise is resolved. An example will make this clear:</p>
<p>The receiver:</p>
<pre>void myHandler(Message&lt;String&gt; message) {
  print("I received a message ``message.body``");

  // Do some stuff

  // Now reply to it
  message.reply("This is a reply");
}
</pre>
<p>The sender:</p>
<pre>value reply = eb.send&lt;String&gt;("test.address", "This is a message");
reply.then_((Message&lt;String&gt; message) =&gt; println("I received a reply ``message.body``"));
</pre>
<p>It is legal also to send an empty reply or a null reply (<em>todo</em>).</p>
<p>The replies themselves can also be replied to so you can create a dialog between two different verticles consisting of multiple rounds.</p>
<h3>Specifying timeouts for replies</h3>
<p><em>Not yet in 2.0</em></p>
<h3>Getting notified of reply failures</h3>
<p><em>Not yet in 2.0</em></p>
<h2>Message types</h2>
<p>The message you send can be any of the following types:</p>
<ul>
<li>boolean</li>
<li>byte[]</li>
<li>double</li>
<li>long</li>
<li>java.lang.String</li>
<li>org.vertx.java.core.json.JsonObject</li>
<li>org.vertx.java.core.json.JsonArray</li>
</ul>
<p>The following types are not supported at the moment</p>
<ul>
<li>short</li>
<li>float</li>
<li>integer</li>
<li>org.vertx.java.core.buffer.Buffer</li>
<li>byte</li>
<li>character</li>
</ul>
<p>Vert.x buffers and JSON objects and arrays are copied before delivery if they are delivered in the same JVM, so different verticles
can't access the exact same object instance which could lead to race conditions.</p>
<p>Here are some more examples:</p>
<p>Send some numbers:</p>
<pre>eb.send("test.address", 1234);
eb.send("test.address", 3.14159);
</pre>
<p>Send a boolean:</p>
<pre>eb.send("test.address", true);
</pre>
<p>Send a JSON object:</p>
<pre>value obj = new Object { "foo"-&gt;"wibble" };
eb.send("test.address", obj);
</pre>
<p>Null messages can also be sent (not supported at the moment):</p>
<pre>eb.send("test.address", null);
</pre>
<p>It's a good convention to have your verticles communicating using JSON - this is because JSON is easy to generate and parse
for all the languages that Vert.x supports.</p>
<h1>Distributed event bus</h1>
<p>To make each Vert.x instance on your network participate on the same event bus, start each Vert.x instance with the
-cluster command line switch.</p>
<p>See the chapter in the main manual on <a href="http://vertx.io/core_manual_java.html">running Vert.x</a> for more information on this.</p>
<p>Once you've done that, any Vert.x instances started in cluster mode will merge to form a distributed event bus.</p>
</div><div class='by section'><span class='title'>By: </span><span class='value'>Julien Viet</span></div></div><table id='section-aliases' class='table table-condensed table-bordered table-hover'><thead><tr class='table-header' title='Click for expand/collapse'><td colspan='2'><i class='icon-expand'></i>Aliases</td></tr></thead><tbody><tr><td id='Payload' nowrap><i class='icon-type-alias'></i>Payload</td><td><a class='link-one-self' title='Link to this declaration' href='../eventbus/index.html#Payload'><i class='icon-link'></i></a><div class='signature'><span class='modifiers'>shared</span> Payload<span class='specifier'>=> </span><span title='ceylon.language::String'>String</span>|<span title='ceylon.json::Object'>Object</span>|<span title='ceylon.json::Array'>Array</span>|<span title='ceylon.language::Integer'>Integer</span>|<span title='ceylon.language::Float'>Float</span>|<span title='ceylon.language::Boolean'>Boolean</span>|<span title='java.lang::ByteArray'>ByteArray</span></div><div class='description'><div class='doc section'><p>Alias for the type of a message payload</p>
</div></div></td></tr></tbody></table><table id='section-classes' class='table table-condensed table-bordered table-hover'><thead><tr class='table-header' title='Click for expand/collapse'><td colspan='2'><i class='icon-expand'></i>Classes</td></tr></thead><tbody><tr><td id='EventBus' nowrap><i class='icon-class'></i><a class='link-discreet' href='../eventbus/EventBus.type.html'>EventBus</a></td><td><a class='link-one-self' title='Link to this declaration' href='../eventbus/index.html#EventBus'><i class='icon-link'></i></a><div class='signature'><span class='modifiers'>shared</span> <a class='link' href='../eventbus/EventBus.type.html' title='Go to io.vertx.ceylon.eventbus::EventBus'>EventBus</a></div><div class='description'><div class='doc section'><p>A distributed lightweight event bus which can encompass multiple vert.x instances.
The event bus implements publish / subscribe, point to point messaging and request-response messaging.</p>
<p>Messages sent over the event bus are represented by instances of the <a class='link' href='../eventbus/Message.type.html' title='Go to io.vertx.ceylon.eventbus::Message'>Message</a> class.</p>
<p>For publish / subscribe, messages can be published to an address using one of the <code>publish</code> methods. An
address is a simple <code>String</code> instance.</p>
<p>Handlers are registered against an address. There can be multiple handlers registered against each address, and a particular handler can
be registered against multiple addresses. The event bus will route a sent message to all handlers which are
registered against that address.</p>
<p>For point to point messaging, messages can be sent to an address using one of the <code>send</code> methods.
The messages will be delivered to a single handler, if one is registered on that address. If more than one
handler is registered on the same address, Vert.x will choose one and deliver the message to that. Vert.x will
aim to fairly distribute messages in a round-robin way, but does not guarantee strict round-robin under all
circumstances.</p>
<p>All messages sent over the bus are transient. On event of failure of all or part of the event bus messages
may be lost. Applications should be coded to cope with lost messages, e.g. by resending them, and making application
services idempotent.</p>
<p>The order of messages received by any specific handler from a specific sender should match the order of messages
sent from that sender.</p>
<p>When sending a message, a reply handler can be provided. If so, it will be called when the reply from the receiver
has been received. Reply messages can also be replied to, etc, ad infinitum</p>
<p>Different event bus instances can be clustered together over a network, to give a single logical event bus.<p>
Instances of EventBus are thread-safe.</p>
<p>If handlers are registered from an event loop, they will be executed using that same event loop. If they are
registered from outside an event loop (i.e. when using Vert.x embedded) then Vert.x will assign an event loop
to the handler and use it to deliver messages to that handler.</p>
</div></div></td></tr><tr><td id='Message' nowrap><i class='icon-class'></i><a class='link-discreet' href='../eventbus/Message.type.html'>Message</a></td><td><a class='link-one-self' title='Link to this declaration' href='../eventbus/index.html#Message'><i class='icon-link'></i></a><div class='signature'><span class='modifiers'>shared</span> <a class='link' href='../eventbus/Message.type.html' title='Go to io.vertx.ceylon.eventbus::Message'>Message</a>&lt;<span class='type-parameter'>T</span> = <span title='ceylon.language::Anything'>Anything</span>&gt;</div><div class='description'><div class='doc section'><p>Represents a message on the event bus.</p>
</div></div></td></tr></tbody></table></div><script type='text/javascript'>var resourceBaseUrl = '../.resources/'</script><script type='text/javascript' src='../.resources/jquery-1.8.2.min.js'></script><script type='text/javascript' src='../.resources/bootstrap.min.js'></script><script type='text/javascript' src='../.resources/shCore.js'></script><script type='text/javascript' src='../.resources/shAutoloader.js'></script><script type='text/javascript' src='../.resources/shBrushCeylon.js'></script><script type='text/javascript' src='../.resources/index.js'></script><script type='text/javascript' src='../.resources/ceylondoc.js'></script><script type='text/javascript'>jQuery('html').keypress(function(evt){
  evt = evt || window.event;
  var keyCode = evt.keyCode || evt.which;
  if( !evt.ctrlKey && !evt.altKey ) {
    if (keyCode == 63) {
      $('#infoDropdown > .dropdown-toggle').click();
    }
    if(keyCode == 115){
      document.location = '../search.html';
    }
    if(keyCode == 99){
      document.location = '#section-classes';
    }
    if(keyCode == 112){
      document.location = 'index.html';
    }
    if(keyCode == 111){
      document.location = '../index.html';
    }
    if(keyCode == 108){
      document.location = '#section-aliases';
    }
  }
});
enableInfoKeybordShortcut('\\?');
enableInfoKeybordShortcut('s');
enableInfoKeybordShortcut('c');
enableInfoKeybordShortcut('p');
enableInfoKeybordShortcut('o');
enableInfoKeybordShortcut('l');
</script></body></html>